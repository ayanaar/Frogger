#####################################################################
#
# CSC258H5S Fall 2021 Assembly Final Project
# University of Toronto, St. George
#
# Student: Ayanaa Rahman, Student Number: 1007048017
#
 # Bitmap Display Configuration:
 # - Unit width in pixels: 8
 # - Unit height in pixels: 8
 # - Display width in pixels: 256
 # - Display height in pixels: 256
 # - Base Address for Display: 0x10008000 ($gp)
 #
# Which milestone is reached in this submission?
# (See the assignment handout for descriptions of the milestones)
# - Milestone 2 (choose the one the applies)
#
# Which approved additional features have been implemented?
# (See the assignment handout for the list of additional features)
# 1. (fill in the feature, if any)
# 2. (fill in the feature, if any)
# 3. (fill in the feature, if any)
# ... (add more if necessary)
#
# Any additional information that the TA needs to know:
# - (write here, if any)
#
#####################################################################

.data
	displayAddress: .word 0x10008000
	# Colours 
	blue: .word 0x285dff
	grey: .word  0x858585
	pink: .word 0xff78ff
	yellow: .word 0xffe53c
	green: .word  0x2ef414
	brown: .word 0x996600
	finalArea: .word 0x00e08e
	turtleColour: .word 0x5bcc00
	truckColor: .word 0xef41414
	# Below are the positions and areas of objects that I will use
	# Length of each object is 2
	# 2 Rows Wide 
	intialfrogPos: .word 3904, 3908, 4032, 4036
	log1iPos: .word 512,516,520,524,528,532,536,540,544,548
	log2iPos: .word 560, 564, 568, 572
	log3iPos: .word 596, 600, 604, 608, 612, 616, 620, 624
	log4iPos: .word 1036, 1040, 1044, 1048, 1052
	log5iPos: .word 1088, 1092
	log6iPos: .word 1116, 1120, 1124, 1128, 1132, 1136
	log7iPos: .word 1536,1540,1544,1548,1552,1556,1560,1564,1568,1572,1576,1580
	log8iPos: .word 1600, 1604, 1608, 1612, 1616
	lengthLog1: .word 10
	lengthLog2: .word 4
	lengthLog3: .word 8
	lengthLog4: .word 5
	lengthLog5: .word 2
	lengthLog6: .word 6
	lengthLog7: .word 12
	log8Length: .word 5
	# Trucks width is 8 and
	# Cars width is 4 (there are 12 rows in total)
	truck1iPos: .word 2332,2336,2340,2344,2348,2352,2356,2360,2460,2464,2468,2472,2476,2480,2484,2488
	truck2iPos: .word 2568,2572,2576,2580,2584,2588,2592,2596, 2696, 2700, 2704, 2708, 2712,2716, 2720, 2724
	truck3iPos: .word 2864, 2868, 2872, 2876, 2880, 2884, 2888, 2892, 2992, 2996, 3000, 3004, 3008, 3012, 3016, 3020
	truck4iPos: .word 3108, 3112, 3116, 3120, 3124, 3128, 3132, 3136, 3236, 3240, 3244, 3248, 3252, 3256, 3260, 3264
	truck5iPos: .word 3388, 3392, 3396, 3400, 3404, 3408, 3412, 3416, 3516, 3520, 3524, 3528, 3532, 3536, 3540, 3544
	truck6iPos: .word 3664, 3668, 3672, 3676, 3680, 3684, 3688, 3692, 3792, 3796, 3800, 3804, 3808, 3812, 3816, 3820
	car1iPos: .word 2388, 2392, 2396, 2400, 2516, 2520, 2524, 2528
	car2iPos: .word 2632, 2636, 2640, 2644, 2760, 2764, 2768, 2772
	car3iPos: .word 2924, 2928, 2932, 2936, 3052, 3056, 3060, 3064
	car4iPos: .word 3072, 3076, 3080, 3084, 3200, 3204, 3208, 3212
	car5iPos: .word 3356, 3360, 3364, 3368, 3484, 3488, 3492, 3496
	car6iPos: .word 3600, 3604, 3608, 3612, 3728, 3732, 3736, 3740
	# Turtles are 2 rows wide 
	turtle1iPos: .word	764, 768, 772, 892, 896, 900
	turtle2iPos: .word	792, 796, 800, 920, 924, 928
	turtle3iPos: .word 1300, 1304, 1308, 1428, 1432, 1436
	turtle4iPos: .word 1368, 1372, 1496, 1500
	turtle5iPos: .word 1804, 1808, 1932, 1936
	turtle6iPos: .word 1816, 1820, 1824, 1944, 1948, 1952
	lengthTurtle1: .word 3
	lengthTurtle2: .word 3
	lengthTurtle3: .word 3
	lengthTurtle4: .word 2
	lengthTurtle5: .word	2
	lengthTurtle6: .word 3
.text 	
# Main gain loop
main_game_loop:
	jal draw_background
	jal load_screen	# Load items in their intial spots
	j log_shift_main
log_shift_main:
	lw $t8, 0xffff0000
 	beq $t8, 1, keyboard_input
 	j sleep
keyboard_input:
 	# Get keyboard input and move frog accordingly
 	lw $t2, 0xffff0004
	beq $t2, 0x61, respond_to_a
 	beq $t2, 0x77, respond_to_w
 	beq $t2, 0x73, respond_to_s
 	beq $t2, 0x64, respond_to_d
 	j sleep

respond_to_d: 
	jal shift_frog_right
	j sleep
respond_to_w: 
	jal shift_frog_up
	j sleep
respond_to_a: 
	jal shift_frog_left
	j sleep
respond_to_s: 
	jal shift_frog_down
	j sleep

sleep:
	jal draw_background	# Draw the background again
	jal main_log_shift
	jal main_vehicle_shift
 	jal load_screen
	li $v0, 32
	la $a0, 300
	syscall
	j log_shift_main	# Loop 
	
load_screen:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
 	jal draw_frog	# Calling draw functions
	li $a0, 1	# Address used to draw log1 to log8
	li $t2, 9	# Loop will stop when it completes drawing all 8 logs
main_log_loop: beq $a0, $t2, all_logs_drawn	
	jal draw_log	# Call to the draw_log function
	add $a0, $a0, 1 	#Increment by 1
	li $t2, 9
	j main_log_loop		# Loop over
all_logs_drawn:	li $a0, 1	
ct_loop: beq $a0, 7, done_drawing	# Will loop 6 times before stopping
	jal draw_truck		# Drawing functions
	jal draw_car
	jal draw_turtle # Loop also applies to turtles, since there is 6 of them as well
	add $a0, $a0, 1 	# Increment by 1 
	j ct_loop
done_drawing: lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

draw_background: 
	li $a1, 0	# Original drawing point
	li $t3, 1664	# Found using trial and error
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
loop_for_background: beq $a1, $t3, End # Keeps looping until accumulator reaches the needed limit 
					#Increments by 4 
	# Drawing the background
	jal first_safe_area
	jal goal_zone
	jal road_zone
	jal middle_safe_zone
	jal water
	addi $a1, $a1, 4 # Increments by 4 
	li $t3, 1664
	j loop_for_background	# Return to start of loop
End: 	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

main_log_shift:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	li $a2, 1
	li $t0, 9
log_shift:	beq $a2, $t0, other_log_shift	# Will shift all the logs
	jal shifting_logs	# Shifting each individual log
	addi $a2, $a2, 1	# Increment by 1
	li $t0, 9
	j log_shift	# Return to the start of the loop
other_log_shift:	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra
	
main_vehicle_shift:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	li $a2, 1
	li $t0, 7
vehicle_shift:	beq $a2, $t0, other_vehicle_shift	# Shifts the cars, trucks and turtles
	jal shift_trucks	# Shifting each individual truck
	jal shift_cars		# Shifting each individual car
	jal shift_turtles	# Shifting each individual turtle, turtle included since there is also 6 of them
	addi $a2, $a2, 1	# Increment by 1
	li $t0, 9
	j vehicle_shift	# Return to the start of the loop
other_vehicle_shift:	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

first_safe_area:	# Loading the first safe area
	lw $t0, displayAddress	
	lw $t1, yellow
	li $t2, 3712	# Intial point for the first start area, found through trial and error
	la $t7, ($a1)	# Loading the $t7 register with appropriate increment 
	addu $t5, $t7, $t2	# Adding the initial block to draw to the current increment, to fill all the desired bits
	addu $t6, $t5, $t0	# Adding the bit to draw in to the diplay address
	sw $t1, ($t6)	# Storing changes to displayAddress
	jr $ra	# Return back to the orginal screen/background

middle_safe_zone:		# Loading the middle safe zone
	lw $t0, displayAddress
	lw $t1, yellow
	li $t2, 2048	# Intial point for middle safe zone, found through trial and error
	la $t7, ($a1)	# Loading the $t7 register with the appropriate increment
	subi, $t4, $t7, 255	# Must draw a bit more for some regions, thus we need to verify if we have reached the desired bits 
				# for the middle safe zone
	bgez $t4, Escape	# Already have drawn the required bits, jump back using Escape
	addu $t5, $t7, $t2	# Adding the first block to draw to the current increment, to fill all the desired bit
	addu $t6, $t5, $t0	# Adding the bit to draw in to the diplay address 
	sw $t1, ($t6)	# Storing changes to displayAddress
Escape:	jr $ra	# Loop again to load_screen

road_zone:		# Loading the road zone
	lw $t0, displayAddress
	lw $t1, grey
	li $t2, 2176	# Intial point for road region, found through trial and error
	la $t7, ($a1)	# Loading the $t7 register with the appropriate increment
	add $t5, $t7, $t2	# Adding the first block to draw to the current increment, to fill all the desired bit
	add $t0, $t5, $t0	# Adding the bit to draw in to the diplay address 
	sw $t1, ($t0)	# Storing changes to displayAddress
	jr $ra	# Loop again to load_screen
	
water:		# Loading the water
	lw $t0, displayAddress
	lw $t1, blue
	li $t2, 384	# Intial point for water region, , found through trial and error 
	la $t7, ($a1)	# Loading the $t7 register with the appropriate increment
	addu $t6, $t7, $t2	# Adding the first block to draw to the current increment, to fill all the desired bit
	addu $t0, $t0, $t6	# Adding the bit to draw in to the diplay address
	sw $t1, ($t0)	# Storing changes to displayAddress
	jr $ra	# Loop again to load_screen

goal_zone:		# Loading the goal zone
	lw $t0, displayAddress
	lw $t1, finalArea
	la $t7, ($a1)	# Loading the $t7 register with the appropriate increment
	li $t2, 0	# Intial point for goal region, found through trial and error
	subi $t4, $t7, 511	# Must draw a bit more for some regions, thus we need to verify if we have reached the desired bits 
				# for this goal zone
	bgez $t4, ELSE		# Already have drawn the required bits, jump back
	add $t5, $t7, $t2	# Adding the first block to draw to the current increment, to fill all the desired bit
	add $t0, $t5, $t0	# Adding the bit to draw in to the diplay address 
	sw $t1, ($t0)	# Storing changes to displayAddress
ELSE:	jr $ra

draw_log:
	la $t7, ($a0)		# First, find the selected log, that needs to be drawn, this value is set using the loop in initial screen (accepts values 1-8)
	beq $t7, 1, select_log_1	# Once the selected log is found, it goes to its correpsonding select_log_y 
	beq $t7, 2, select_log_2
	beq $t7, 3, select_log_3
	beq $t7, 4, select_log_4
	beq $t7, 5, select_log_5
	beq $t7, 6, select_log_6
	beq $t7, 7, select_log_7
	beq $t7, 8, select_log_8
select_log_1: la $t2, log1iPos	# Log1 was selected, set $t2 to its location
	lw $t3, lengthLog1	# Log1 was selected set $t3 to its length
	j log_display	# Go through all the branches to select the correct log
select_log_2: la $t2, log2iPos # Log2 was selected, set $t2 to its location
	lw $t3, lengthLog2	# Log2 was selected set $t3 to its length
	j log_display		# Go through all the branches to select the correct log
select_log_3: la $t2, log3iPos # Log3 was selected, set $t2 to its location
	lw $t3, lengthLog3	# Log3 was selected set $t3 to its length
	j log_display		# Go through all the branches to select the correct log
select_log_4: la $t2, log4iPos #Same comments apply to the other ones below
	lw $t3, lengthLog4
	j log_display
select_log_5: la $t2, log5iPos
	lw $t3, lengthLog5
	j log_display
select_log_6: la $t2, log6iPos
	lw $t3, lengthLog6
	j log_display
select_log_7: la $t2, log7iPos
	lw $t3, lengthLog7
	j log_display
select_log_8: la $t2, log8iPos
	lw $t3, lengthLog1
	j log_display
log_display:	lw $t0, displayAddress	# Loading the appropriate colors and displayAdress
	lw $t1, brown
	
	sll $t3, $t3, 2
log_loop:	bltz $t3, complete_log	# Reaches 0, all bits are drawn
	lw $t6, 0($t2)
	add $t6, $t6, $t3	# Adding the current increment of 4s to the current position, giving us the new address
	add $t6, $t6, $t0	# Adding the desired bit to the displayAddress in order to draw
	addi $t7, $t6, 128	# Adding 128 to ensure it also draws the next rows bits 
	sw $t1, ($t6)		# Drawing the first row bits
	sw $t1, ($t7)		# Drawing the second row bits 
	subi $t3, $t3, 4	# Decrementing the accumulator
	j log_loop	# Loop over aggain
complete_log: jr $ra	# GO back to load_screen

draw_frog:		# Drawing the frog
	lw $t0, displayAddress	
	lw $t1, green
	la $t3, intialfrogPos	# Load the frog's intial position
	lw $t4, 0($t3)		# Stored in an array of 4 words, need to load $t4-$t7 with each bit 
	lw $t5, 4($t3)
	lw $t6, 8($t3)
	lw $t7, 12($t3)
	add $t4, $t4, $t0	# Adding the displayAddress to each of the bits 
	add $t5, $t5, $t0
	add $t6, $t6, $t0
	add $t7, $t7, $t0
	sw $t1, ($t4)		# Store all those bits within thescreen
	sw $t1, ($t5)
	sw $t1, ($t6)
	sw $t1, ($t7)
	jr $ra		# Loop back to initialScreen

# Used the same implementation as draw_log
draw_truck: 
	lw $t0, displayAddress 
	# Figuring our what truck should be selected 
	la $t5, ($a0) # First, find the selected truck that needs to be drawn, this value is set using the loop in initial screen (accepts values 1-8)
	li $t6, 1 # Once the selected truck is found, it goes to its correpsonding select_truck_y 
	beq $t5, $t6, select_truck_1 # truck 1 was selected, set $t6 to its location
	li $t6, 2
	beq $t5, $t6, select_truck_2
	li $t6, 3
	beq $t5, $t6, select_truck_3
	li $t6, 4
	beq $t5, $t6, select_truck_4
	li $t6, 5
	beq $t5, $t6, select_truck_5
	li $t6, 6
	beq $t5, $t6, select_truck_6
select_truck_1:	la $t2, truck1iPos
		j continue
select_truck_2:	la $t2, truck2iPos
		j continue
select_truck_3:	la $t2, truck3iPos
		j continue
select_truck_4:	la $t2, truck4iPos
		j continue
select_truck_5:	la $t2, truck5iPos
		j continue
select_truck_6:	la $t2, truck6iPos
		j continue
continue:	li $t3, 8
	li $t4, 4
	mul $t3, $t3, $t4
truck_loop:	blez $t3, complete_truck
	lw $t1, truckColor
	lw $t6, ($t2)
	add, $t6, $t6, $t3
	add, $t6, $t6, $t0
	addi $t7, $t6, 128
	sw $t1, ($t6)
	sw $t1, ($t7)
	subi $t3, $t3, 4
	j truck_loop
complete_truck: jr $ra

draw_turtle:
	# Figuring out which turtle should be selected
	# First, find the selected turtle that needs to be drawn, this value is set using the loop in initial screen (accepts values 1-8)
	la $t5, ($a0) 
	li $t6, 1 # Once the selected turtle is found, it goes to its correpsonding select_turtle_y 
	beq $t5, $t6, select_turtle_1
	li $t6, 2
	beq $t5, $t6, select_turtle_2
	li $t6, 3
	beq $t5, $t6, select_turtle_3
	li $t6, 4
	beq $t5, $t6, select_turtle_4
	li $t6, 5
	beq $t5, $t6, select_turtle_5
	li $t6, 6
	beq $t5, $t6, select_turtle_6
select_turtle_1:	la $t2, turtle1iPos
		lw $t3, lengthTurtle1
		j continue_3
select_turtle_2:	la $t2, turtle2iPos
		lw $t3, lengthTurtle2
		j continue_3
select_turtle_3:	la $t2, turtle3iPos
		lw $t3, lengthTurtle3
		j continue_3
select_turtle_4:	la $t2, turtle4iPos
		lw $t3, lengthTurtle4
		j continue_3
select_turtle_5:	la $t2, turtle5iPos
		lw $t3, lengthTurtle5
		j continue_3
select_turtle_6:	la $t2, turtle6iPos
		lw $t3, lengthTurtle6
		j continue_3
continue_3:	sll $t3, $t3, 2
	lw $t0, displayAddress
turtle_loop:	blez $t3, completed_turtle
	lw $t1, turtleColour
	lw $t6, ($t2)		# Loading the array
	add $t6, $t6, $t3	# Adding to the current increment 
	add $t6, $t6, $t0	# Adding to the display adress
	addi $t7, $t6, 128	
	sw $t1, ($t6)
	sw $t1, ($t7)
	subi $t3, $t3, 4
	j turtle_loop
completed_turtle: jr $ra 

draw_car:
	lw $t0, displayAddress
	lw $t1, pink
	# Figuring out what car should be selected
	la $t5, ($a0)
	li $t6, 1
	beq $t5, $t6, select_car_1
	li $t6, 2
	beq $t5, $t6, select_car_2
	li $t6, 3
	beq $t5, $t6, select_car_3
	li $t6, 4
	beq $t5, $t6, select_car_4
	li $t6, 5
	beq $t5, $t6, select_car_5
	li $t6, 6
	beq $t5, $t6, select_car_6
select_car_1:	la $t2, car1iPos
		j continue_1
select_car_2:	la $t2, car2iPos
		j continue_1
select_car_3:	la $t2, car3iPos
		j continue_1
select_car_4:	la $t2, car4iPos
		j continue_1
select_car_5:	la $t2, car5iPos
		j continue_1
select_car_6:	la $t2, car6iPos
		j continue_1
continue_1:	li $t3, 16
car_loop:	blez $t3, completed_car
	lw $t6, ($t2)
	add, $t6, $t6, $t3
	add, $t6, $t6, $t0
	addi $t7, $t6, 128
	sw $t1, ($t6)
	sw $t1, ($t7)
	subi $t3, $t3, 4
	j car_loop
completed_car: jr $ra

shifting_logs:	# Shifting all logs one at a time
	la $t0, ($a2)	
	beq $t0, 1, log1_shifting
	beq $t0, 2, log2_shifting
	beq $t0, 3, log3_shifting
	beq $t0, 4, log4_shifting
	beq $t0, 5, log5_shifting
	beq $t0, 6, log6_shifting
	beq $t0, 7, log7_shifting
	beq $t0, 8, log8_shifting
log1_shifting: 	 
	la $t1, log1iPos 	# Current Position of the first log
	lw $t3, lengthLog1	
	li $t4, 640	# Limit for the log, ensures that if it loops over the same row it reaches this number
	j selected_log_shift
log2_shifting: 
	la $t1, log2iPos # Current Position of the second log
	lw $t3, lengthLog2
	li $t4, 640
	j selected_log_shift	
log3_shifting: 
	la $t1, log3iPos # Current Position of the third log
	lw $t3, lengthLog3
	li $t4, 640
	j selected_log_shift
log4_shifting: 
	la $t1, log4iPos # Current Position of the fourth log
	lw $t3, lengthLog4
	li $t4, 1152
	j selected_log_shift
log5_shifting: 
	la $t1, log5iPos # Current Position of the fifth log
	lw $t3, lengthLog5
	li $t4, 1152
	j selected_log_shift
log6_shifting: 
	la $t1, log6iPos # Current Position of the sixth log
	lw $t3, lengthLog6
	li $t4, 1152
	j selected_log_shift
log7_shifting: 
	la $t1, log7iPos # Current Position of the seventh log
	lw $t3, lengthLog7
	li $t4, 1664
	j selected_log_shift
log8_shifting: 
	la $t1, log8iPos # Current Position of the eighth log
	lw $t3, log8Length
	li $t4, 1664
	j selected_log_shift
selected_log_shift: # Selected log shift
	sll $t3, $t3, 2	# Multiply by 4	
	sub $t4, $t4, $t3	# Wrap over limit for the log
	li $t2, 0	# Accumulator, needed to shift all the bits of the log
log_shift_log:	bge $t2, $t3, completed_log	# It has reached the length of bits, thus it has been shifted to so we got completed_log
	lw $t5, ($t1)	# Loading word
	add $t5,$t5,$t2	# Finding the it we need to add to 
	addi $t6, $t5, 4	# Adding 4 to shift
	lw $t5, ($t1)
	add $t5,$t1,$t2		# $t5 goes to correct address 
	sw $t6, ($t5)		# Storeing the value
	addi $t2, $t2, 4 # Incrementing 
	beq $t6, $t4, wrap_over_log	# Once I hit the boundary, need to move up a row 
	j log_shift_log # Loop again
wrap_over_log: subi $t6, $t6, 128	
	sw $t6, ($t5)		# Storing the most recent value
	j log_shift_log
completed_log: 	jr $ra	# Completed log, go back into the loop	
	
shift_frog_left:
	la $t1, intialfrogPos
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	lw $t4, 8($t1)
	lw $t5, 12($t1)
	li $t7, 4096
	li $t0, 0
check_loop:	beq $t0, $t7, check_shift_left
	beq $t4, $t0, left_completed
	addi $t0, $t0, 128
	j check_loop
check_shift_left:	sub $t2, $t2, 8
	sub $t3, $t3, 8
	sub $t4, $t4, 8
	sub $t5, $t5, 8
	sw $t2, 0($t1)
	sw $t3, 4($t1)
	sw $t4, 8($t1)
	sw $t5, 12($t1)
	j left_completed
left_completed: jr $ra


shift_frog_up:
	la $t1, intialfrogPos
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	lw $t4, 8($t1)
	lw $t5, 12($t1)
	li $t7, 124
	li $t0, 0
up_check_loop:	beq $t0, $t7, check_shift_up
	beq $t2, $t0, up_completed
	addi $t0, $t0, 4
	j up_check_loop
check_shift_up:	sub $t2, $t2, 256
	sub  $t3, $t3, 256
	sub $t4, $t4, 256
	sub $t5, $t5, 256
	sw $t2, 0($t1)
	sw $t3, 4($t1)
	sw $t4, 8($t1)
	sw $t5, 12($t1)
	j up_completed
up_completed: jr $ra

shift_frog_down:
	la $t1, intialfrogPos
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	lw $t4, 8($t1)
	lw $t5, 12($t1)
	li $t7, 4092
	li $t0, 3968
check_shift_down_loop:	beq $t0, $t7, check_shift_down
	beq $t5, $t0, down_completed
	addi $t0, $t0, 4
	j check_shift_down_loop
check_shift_down:	add $t2, $t2, 256
	add $t3, $t3, 256
	add $t4, $t4, 256
	add $t5, $t5, 256
	sw $t2, 0($t1)
	sw $t3, 4($t1)
	sw $t4, 8($t1)
	sw $t5, 12($t1)
	j down_completed
down_completed: jr $ra

shift_frog_right:
	la $t1, intialfrogPos
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	lw $t4, 8($t1)
	lw $t5, 12($t1)
	li $t7, 4220
	li $t0, 124
check_shift_right_loop:	beq $t0, $t7, check_shift_right
	beq $t3, $t0, right_completed
	addi $t0, $t0, 128
	j check_shift_right_loop
check_shift_right:	add $t2, $t2, 8
	add $t3, $t3, 8
	add $t4, $t4, 8
	add $t5, $t5, 8
	sw $t2, 0($t1)
	sw $t3, 4($t1)
	sw $t4, 8($t1)
	sw $t5, 12($t1)
	j right_completed
right_completed: jr $ra

shift_turtles:	# # Shifting all turtles one at a time
	la $t0, ($a2)	# Set from the main loop 
	li $t5, 1	# Need to reset this alot to verify which selecgted turtle needs to shift
	beq $t5, $t0, shift_turtle_1
	li $t5, 2
	beq $t5, $t0, shift_turtle_2
	li $t5, 3
	beq $t5, $t0, shift_turtle_3
	li $t5, 4
	beq $t5, $t0, shift_turtle_4
	li $t5, 5
	beq $t5, $t0, shift_turtle_5
	li $t5, 6
	beq $t5, $t0, shift_turtle_6
shift_turtle_1: 	 
	la $t1, turtle1iPos 	# Intial Position for turtle 1
	lw $t3, lengthTurtle1	# Limiter of the bits for the turtle
	li $t4, 764	# Limit for the turtle, ensures that it loops over the same row if it reaches this number
	j turtle_selected_shift
shift_turtle_2: 
	la $t1, turtle2iPos
	lw $t3, lengthTurtle2
	li $t4, 764
	j turtle_selected_shift	
shift_turtle_3: 
	la $t1, turtle3iPos
	lw $t3, lengthTurtle3
	li $t4, 1276
	j turtle_selected_shift
shift_turtle_4: 
	la $t1, turtle4iPos
	lw $t3, lengthTurtle4
	li $t4, 1276
	j turtle_selected_shift
shift_turtle_5: 
	la $t1, turtle5iPos
	lw $t3, lengthTurtle5
	li $t4, 1778
	j turtle_selected_shift
shift_turtle_6: 
	la $t1, turtle6iPos
	lw $t3, lengthTurtle6
	li $t4, 1778
	j turtle_selected_shift

turtle_selected_shift: 
	sll $t3, $t3, 2	# Multiply by 4	
	sub $t4, $t4, $t3	# Wrap over limit
	li $t2, 0	# Accumulator, shifting the bits of the turtle
turtle_shifting_loop:	beq $t2, $t3, turtle_shift_complete	# Reaches the length of bits, it has been shifted, to get to turtle_shift_complete
	add $t5,$t1,$t2	# Finding the bit we need to add to
	lw $t5, ($t5)	# Loading word at address
	subi $t6, $t5, 4	# In order to shift it, we need to add 4
	add $t5,$t1,$t2		# $t5 corresponds to the correct address 
	sw $t6, ($t5)		# Storing the most recent value
	addi $t2, $t2, 4 # Need to increment by 4
	ble $t6, $t4, wrapover_turtle	# Once we hit the boundary, shift up a row 
	j turtle_shifting_loop # Loop again 
wrapover_turtle: addi $t6, $t6, 128	# Wrapping over
	sw $t6, ($t5)		# Storing the most recent value 
	
	j turtle_shifting_loop

turtle_shift_complete: jr $ra

shift_trucks:
	la $t5, ($a2)	# Set from the main loop 
	beq $t5, 1, shift_truck1 
	beq $t5, 2, shift_truck2 
	beq $t5, 3, shift_truck3 
	beq $t5, 4, shift_truck4 
	beq $t5, 5, shift_truck5 
	beq $t5, 6, shift_truck6 
shift_truck1:	
	la $t0, truck1iPos
	li $t1, 2304		# Limit for row 1
	li $t2, 2432		# Limit for row 2
	li $t5, 0	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
shift_truck2:	
	la $t0, truck2iPos
	li $t1, 2684		# Limit for row 1
	li $t2, 2812		# Limit for row 2
	li $t5, 1	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
shift_truck3:	
	la $t0, truck3iPos
	li $t1, 2816		# Limit for row 1
	li $t2, 2944		# Limit for row 2
	li $t5, 0	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
shift_truck4:	
	la $t0, truck4iPos
	li $t1, 3196		# Limit for row 1
	li $t2, 3324		# Limit for row 2
	li $t5, 1	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
shift_truck5:	
	la $t0, truck5iPos
	li $t1, 3328		# Limit for row 1
	li $t2, 3456		# Limit for row 2
	li $t5, 0	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
shift_truck6:	
	la $t0, truck6iPos
	li $t1, 3708		# Limit for row 1
	li $t2, 3836		# Limit for row 2
	li $t5, 1	# Factor that will decide if trucks should shift to the left or right
	j right_truck_complete
right_truck_complete:	li $t7, 0
	lw $t4, truckColor
shift_right_truck_loop:	beq $t7, 64, truck_shift_done
	# Need to find truck address
	add $t6, $t0, $t7
	lw $t2, ($t6)
	beq $t5, 0, shift_truck_left
	addi $t6, $t2, 4 	# Shifting right
	bge $t7, 32, row2_shift_truck
	ble $t6, $t1, row1_truck
	subi $t6, $t6, 128
	j row1_truck
shift_truck_left:
	subi $t6, $t2, 4 	# Shifting left
	bge $t7, 32, row2_shift_truck_left
	bge $t6, $t1, row1_truck
	addi $t6, $t6, 128
	j row1_truck
row1_truck:
	add $t2, $t0, $t7	
	sw $t6, ($t2)
	addi $t7, $t7, 4
	j shift_right_truck_loop
row2_shift_truck:
	ble $t6, $t2, row1_truck
	subi $t6, $t6, 128
	j row1_truck
row2_shift_truck_left:
	bge $t6, $t2, row1_truck
	addi $t6, $t6, 128
	j row1_truck	
truck_shift_done: jr $ra

shift_cars:
	la $t5, ($a2)	# Set from main loop 
	beq $t5, 1, shift_car_1 
	beq $t5, 2, shift_car_2 
	beq $t5, 3, shift_car_3 
	beq $t5, 4, shift_car_4 
	beq $t5, 5, shift_car_5 
	beq $t5, 6, shift_car_6 
shift_car_1:	
	la $t0, car1iPos
	li $t1, 2304		# Limit for row 1
	li $t2, 2432		# Limit for row 2
	li $t5, 0	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
shift_car_2:	
	la $t0, car2iPos
	li $t1, 2684		# Limit for row 1
	li $t2, 2812		# Limit for row 2
	li $t5, 1	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
shift_car_3:	
	la $t0, car3iPos
	li $t1, 2816		# Limit for row 1
	li $t2, 2944		# Limit for row 2
	li $t5, 0	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
shift_car_4:	
	la $t0, car4iPos
	li $t1, 3196		# Limit for row 1
	li $t2, 3324		# Limit for row 2
	li $t5, 1	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
shift_car_5:	
	la $t0, car5iPos
	li $t1, 3328		# Limit for row 1
	li $t2, 3456		# Limit for row 2
	li $t5, 0	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
shift_car_6:	
	la $t0, car6iPos
	li $t1, 3708		# Limit for row 1
	li $t2, 3836		# Limit for row 2
	li $t5, 1	# Factor that will decide if car should shift to the left or right
	j car_shift_complete
car_shift_complete:	li $t7, 0
	lw $t4, pink
car_shift_complete_loop:	beq $t7, 32, row_car_shift_done
	# Finding the car address
	add $t6, $t0, $t7
	lw $t2, ($t6)
	beq $t5, 0, shift_car_left
	addi $t6, $t2, 4 	# shifting right
	bge $t7, 32, row_2_car_shift
	ble $t6, $t1, row_1_car_shift
	subi $t6, $t6, 128
	j row_1_car_shift
shift_car_left:
	subi $t6, $t2, 4 	# shifting left
	bge $t7, 32, row_2_car_shift_2
	bge $t6, $t1, row_1_car_shift
	addi $t6, $t6, 128
	j row_1_car_shift
row_1_car_shift:
	add $t2, $t0, $t7	
	sw $t6, ($t2)
	addi $t7, $t7, 4
	j car_shift_complete_loop
row_2_car_shift:
	ble $t6, $t2, row_1_car_shift
	subi $t6, $t6, 128
	j row_1_car_shift
row_2_car_shift_2:
	bge $t6, $t2, row_1_car_shift
	addi $t6, $t6, 128
	j row_1_car_shift
row_car_shift_done: jr $ra

Exit:
 	li $v0, 10 # terminate the program gracefully
 	syscall
